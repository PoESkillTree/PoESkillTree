using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using POESKillTree.Localization;
using POESKillTree.Model;
using POESKillTree.SkillTreeFiles;
using POESKillTree.TreeGenerator.Solver;
using POESKillTree.Utils;

namespace POESKillTree.TreeGenerator.ViewModels
{
    /// <summary>
    /// ViewModel that runs a solver and reports its results.
    /// </summary>
    public sealed class ControllerViewModel : CloseableViewModel
    {
        /// <summary>
        /// The solver run by this ViewModel.
        /// </summary>
        private readonly ISolver _solver;

        private readonly SkillTree _tree;

        /// <summary>
        /// The maximum number of steps the solver does.
        /// </summary>
        private int _maxSteps;

        private HashSet<ushort> _bestSoFar;
        /// <summary>
        /// Gets the best value so far generated by the solver.
        /// </summary>
        /// <remarks>
        /// Setting this updates BestResultText and highlights the
        /// given nodes in the skill tree.
        /// </remarks>
        public HashSet<ushort> BestSoFar
        {
            get { return _bestSoFar; }
            private set
            {
                _bestSoFar = value;
                // BestSoFar.Count - 1 because of the hidden character class start node.
                BestResultText = string.Format(L10n.Plural("Best result so far: {0} point spent",
                    "Best result so far: {0} points spent", (uint)_bestSoFar.Count - 1), _bestSoFar.Count - 1);
                _tree.HighlightedNodes = new HashSet<ushort>(_bestSoFar);
                _tree.DrawNodeBaseSurroundHighlight();
            }
        }

        /// <summary>
        /// Indicates whether running the solver is currently paused.
        /// </summary>
        private bool _isPaused;

        // Once solutionWorker_DoWork is done working in the background, all eventually
        // queued up solutionWorker_ProgressChanged calls return without doing anything.
        // This is mainly noticeable for very small searchSpaces (and therefore a high
        // maxGeneration).
        /// <summary>
        /// Indicates whether the ViewModel should no longer report its progress.
        /// </summary>
        private bool _stopReporting;

        /// <summary>
        /// Token source for cancelling the solver.
        /// </summary>
        private CancellationTokenSource _cts;

        /// <summary>
        /// Used to report progress from the solver running thread to the UI thread.
        /// </summary>
        private readonly IProgress<Tuple<int, HashSet<ushort>>> _progress;

#region Presentation

        private double _progressbarMax;
        /// <summary>
        /// Gets the maximum value the progress can reach.
        /// </summary>
        public double ProgressbarMax
        {
            get { return _progressbarMax; }
            private set { SetProperty(ref _progressbarMax, value); }
        }

        private double _progressbarCurrent;
        /// <summary>
        /// Gets the current progress value.
        /// </summary>
        public double ProgressbarCurrent
        {
            get { return _progressbarCurrent; }
            private set { SetProperty(ref _progressbarCurrent, value); }
        }

        private string _progressbarText = L10n.Message("Initializing...");
        /// <summary>
        /// Gets additional information about the current progress.
        /// </summary>
        public string ProgressbarText
        {
            get { return _progressbarText; }
            private set { SetProperty(ref _progressbarText, value); }
        }

        private bool _progressbarEnabled = true;
        /// <summary>
        /// Gets whether the solver is currently progressing.
        /// </summary>
        public bool ProgressbarEnabled
        {
            get { return _progressbarEnabled; }
            private set { SetProperty(ref _progressbarEnabled, value); }
        }

        private bool _cancelCloseEnabled;
        /// <summary>
        /// Gets whether the Cancel/Close button should be enabled.
        /// </summary>
        public bool CancelCloseEnabled
        {
            get { return _cancelCloseEnabled; }
            private set { SetProperty(ref _cancelCloseEnabled, value); }
        }

        private string _cancelCloseText = L10n.Message("Cancel");
        /// <summary>
        /// Gets the string the Cancel/Close button should show.
        /// </summary>
        public string CancelCloseText
        {
            get { return _cancelCloseText; }
            private set { SetProperty(ref _cancelCloseText, value); }
        }

        private bool _pauseResumeEnabled;
        /// <summary>
        /// Gets whether the Pause/Resume button should be enabled.
        /// </summary>
        public bool PauseResumeEnabled
        {
            get { return _pauseResumeEnabled; }
            private set { SetProperty(ref _pauseResumeEnabled, value); }
        }

        private string _pauseResumeText = L10n.Message("Pause");
        /// <summary>
        /// Gets the string the Pause/Resume button should show.
        /// </summary>
        public string PauseResumeText
        {
            get { return _pauseResumeText; }
            private set { SetProperty(ref _pauseResumeText, value); }
        }

        private string _bestResultText;
        /// <summary>
        /// Gets a string describing the currently best result calculated by the solver.
        /// </summary>
        public string BestResultText
        {
            get { return _bestResultText; }
            private set { SetProperty(ref _bestResultText, value); }
        }

#endregion

#region Commands

        private RelayCommand _pauseResumeCommand;
        /// <summary>
        /// Gets a command that pauses or resumes execution of the solver.
        /// </summary>
        public ICommand PauseResumeCommand
        {
            get { return _pauseResumeCommand ?? (_pauseResumeCommand = new RelayCommand(param => PauseResume())); }
        }

        private RelayCommand _startSolveRelayCommand;
        /// <summary>
        /// Gets a command that starts executing the solver asynchronously.
        /// </summary>
        public ICommand StartSolverCommand
        {
            get { return _startSolveRelayCommand ?? (_startSolveRelayCommand = new RelayCommand(param => StartSolverAsync())); }
        }

#endregion

        /// <summary>
        /// Instantiates a new ControllerViewModel.
        /// </summary>
        /// <param name="solver">The (not null) solver this object should run.</param>
        /// <param name="generatorName">The name suffix shown as DisplayName as 'Skill tree generator - {generatorName}'</param>
        public ControllerViewModel(ISolver solver, string generatorName)
        {
            if (solver == null) throw new ArgumentNullException("solver");

            _solver = solver;
            DisplayName = L10n.Message("Skill tree generator") + " - " + generatorName;
            _tree = _solver.Tree;

            _progress = new Progress<Tuple<int, HashSet<ushort>>>(tuple => ReportProgress(tuple.Item1, tuple.Item2));

            RequestClose += (sender, args) => CancelClose();
        }

        /// <summary>
        /// Starts executing the solver asynchronously.
        /// </summary>
        private async void StartSolverAsync()
        {
            if (await InitializeAsync())
            {
                // only start Solver if initialization was successful.
                await SolveAsync();
            }
        }

        /// <summary>
        /// Initializes the solver asynchronously.
        /// </summary>
        /// <returns>Whether the initialization was successful.</returns>
        private async Task<bool> InitializeAsync()
        {
            try
            {
                _maxSteps = await Task.Run(() =>
                {
#if DEBUG
                    var stopwatch = new Stopwatch();
                    stopwatch.Start();
#endif
                    _solver.Initialize();
#if DEBUG
                    stopwatch.Stop();
                    Debug.WriteLine("Initialization took " + stopwatch.ElapsedMilliseconds + " ms\n-----------------");
#endif
                    return _solver.MaxGeneration;
                });

            }
            catch (InvalidOperationException)
            {
                // Show a dialog and close this if the omitted nodes disconnect the tree.
                Popup.Warning(L10n.Message("The optimizer was unable to find a conforming tree.\nPlease change skill node tagging and try again."));
                // Closes the dialog.
                Result = false;
                return false;
            }

            ProgressbarMax = _maxSteps;
            ProgressbarText = "0/" + _maxSteps;

            CancelCloseEnabled = true;
            PauseResumeEnabled = true;

            return true;
        }

        /// <summary>
        /// Executes the solver asyncronously.
        /// </summary>
        private async Task SolveAsync()
        {
            _cts = new CancellationTokenSource();
            var token = _cts.Token;

            _stopReporting = false;

            HashSet<ushort> result;
            try
            {
                result = await Task.Run(() =>
                {
#if DEBUG
                    var stopwatch = new Stopwatch();
                    stopwatch.Start();
#endif
                    while (!_solver.IsConsideredDone)
                    {
                        _solver.Step();

                        _progress.Report(new Tuple<int, HashSet<ushort>>(_solver.CurrentGeneration, _solver.BestSolution));

                        token.ThrowIfCancellationRequested();
                    }
                    _solver.FinalStep();
#if DEBUG
                    stopwatch.Stop();
                    Debug.WriteLine("Finished in " + stopwatch.ElapsedMilliseconds + " ms\n==================");
#endif
                    return _solver.BestSolution;
                }, token);
            }
            catch (OperationCanceledException)
            {
                PauseResumeEnabled = true;
                _stopReporting = true;
                return;
            }

            _stopReporting = true;

            ProgressbarText = L10n.Message("Finished!");
            CancelCloseText = L10n.Message("Close");
            PauseResumeEnabled = false;
            _isPaused = true;

            // Draw the final solution.
            ProgressbarCurrent = _maxSteps;
            BestSoFar = result;
        }

        /// <summary>
        /// Reports solver progress to be displayed.
        /// </summary>
        /// <param name="step">The number of executed steps.</param>
        /// <param name="bestSoFar">The best result generated to this point.</param>
        private void ReportProgress(int step, HashSet<ushort> bestSoFar)
        {
            if (_stopReporting)
            {
                return;
            }

            ProgressbarCurrent = step;
            ProgressbarText = step + "/" + _maxSteps;
            BestSoFar = bestSoFar;
        }

        /// <summary>
        /// Stop the optimizer and/or close the window.
        /// </summary>
        private void CancelClose()
        {
            if (_isPaused)
            {
                Result = true;
            }
            else
            {
                // The close command executes before the exception in SolveAsync is thrown.
                // Therefore remaining ReportProgress calls may come through before it is deactivated.
                // So it must be deactivated here too.
                _stopReporting = true;
                if (_cts != null) _cts.Cancel();
                Result = false;
            }
        }

        /// <summary>
        /// Pause/Resume execution of the solver.
        /// </summary>
        private async void PauseResume()
        {
            // Pause the optimizer
            if (_isPaused)
            {
                PauseResumeText = L10n.Message("Pause");
                CancelCloseText = L10n.Message("Cancel");
                ProgressbarEnabled = true;
                _isPaused = false;
                await SolveAsync();
            }
            else
            {
                PauseResumeText = L10n.Message("Continue");
                CancelCloseText = L10n.Message("Close");
                // Disable the button until the worker has actually finished.
                PauseResumeEnabled = false;
                ProgressbarEnabled = false;
                _cts.Cancel();
                _isPaused = true;
            }
        }
    }
}